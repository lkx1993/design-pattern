一、Iterator--迭代子模式
	不要只是用具体类来编程，要哟普贤使用抽象类和接口来编程。
	迭代器模式就是书序访问聚集中的对象。需要遍历的对象即聚集对象，迭代器对象用于对聚集对象进行遍历的访问

二、Adapter--适配器模式
	用于填补“现有程序”和“所需程序”之间差异的是设计模式是适配器模式
	类的适配器模式：当希望将一个类转换成满足另一个新街口的类时，可以使用类的适配器模式，创建一个新类，继承原有类，实现新的接口即可
	对象的适配器模式：当希望将一个对象转换成满足里一个新接口的对象时，可以创建一个Wapper类，持有原类的一个实例，在Wapper类的方法中，调用实例的方法就行。
	接口的适配器模式：当不希望实现一个接口中所有的方法是，可以创建一个抽象类Wapper，实现所有方法，我们写的类继承该抽象类即可
	
三、Template Method--模板方法模式
	在父类中定义处理流程的框架，在子类中实现具体处理。
	一个抽象类中，有一个主方法，在定义1~n个方法，可以使抽象的，也可以是实际的方法，定义一个雷，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用。
	
四、Factory Method--工厂方法模式
	1、普通工厂方法模式：建立一个工厂类，对实现了统一接口的一些类进行实例创建。
	2、多个工厂方法模式：对普通工厂方法模式的改进，在普通工厂方法模式中，如果床底的字符串出错，就不能正确穿件对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象
	3、静态工厂方法模式：将多个工厂方法模式里的方法置为静态的，不需要创建实例直接调用即可。
	大多数情况下选择第三种，及防治字符串传输错误，又不用创建工厂类的实例。

五、Singleton--单例模式
	优点：1、对一些创建比较频繁的大型对象，节省系统开销
	2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力
	3、保证类独立控制核心服务流程
	缺点：1、单例模式理解简单，但具体实现还是有一定难度
	2、synchronized关键字锁定的对象，在用的时候，一定要在恰当的地方使用。
	单例和静态类的区别：
	1、静态类不能实现接口
	2、单例可以被延迟初始化，静态类一般在第一次加载的时初始化，延迟有助于提升性能
	3、单例类可以被继承，方法可以被重写
	4、单例类比较灵活，可以实现一些其他功能，只要满足单例的需求

六、Prototype--原型模式
	该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。原型需要实现Cloneable接口，重写clone方法。
	浅复制：使用clone方法复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指的对象。
	深复制：使用字节流输入输出，复制后，基本数据类型和引用类型都是重新创建的。
	
七、Builder--建造者模式
	工厂类模式提供的是创建单个类的模式，而建造者模式真是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同属性，其实建造者模式就是前面工厂方法模式和Test结合起来得到的。
	建造者模式将很多功能集成到一个类里面，可以创造出比较复杂的东西，与工厂模式的区别：工厂模式关注的是创建单个产品，而建造者模式则关注创建对象，多个部分
	
八、Abstract Factory--抽象工厂模式
	模板方法模式：定义一个产品接口，子产品实现该接口，展现不同的内容。例如：Car接口中有driver抽象方法，Bmw类实现类接口并重写driver方法；
	简单工厂方法模式：处理上述的产品节后和子产品类外，定义工厂方法，通过不同的参数传递或方法调用来实现创建不同的子产品的实例；
	工厂方法模式：将上述的工厂类改为工厂接口。根据子产品类来定义子工厂类实现工厂接口，创造出制定类型的子产品的实例；
	抽象工厂方法模式：子产品类不再是单个产品，二十一组产品，例如宝马车下有跑车、赛车、商务车等，子工厂实现类中将划分为多系类型例如跑车工厂生产奔驰跑车和宝马跑车等等。
	
九、Bridge--桥接模式
	类的功能层次结构：实现方法：增加类的子类。
	类的实现层次结构：实现方法：正价接口的实现类
	将抽象化与实现化解耦，是得二者可以独立变化
	
十、Strategy--策略模式
	策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法客户，需要设计一个接口，为一系列的实现类（算法）提供统一的方法。多个实现类实现该接口。
	策略模式多用在算法策略系统中，外部用户系需要决定用哪个算法即可。

十一、Composite--组合模式
	该模式又叫部分-整体模式，在处理类似树形结构的问题是比较方便。
	使用场景：将多个对象组合在一起进行操作，常用语标识树形结构
	
十二、Decorator--装饰模式
	装饰模式就是给一个对象增加一些新功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。
	应用场景：1、需要扩展一个类的功能
	2、动态的为一个对象增加功能，而且还能动态撤销，（继承不能做到这一点，继承的功能是静态的，不能动态的增删）
	缺点：产生过多的相似对象，不易排查
	
十三、Visitor--访问者模式
	访问者模式就是一种分离对象数据结构和行为的方法。通过分离可达到为一个被访问者动态添加新操作而午休做其他修改的效果
	适用场景：1、新功能与现有功能出现兼容
	2、新功能还有可能需要添加
	3、不允许修改原代码
	访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦
	
十四、Chain of Responsibility--责任链模式
	将多个对象组成一条职责链，然后按照他们在职责链上的顺序一个一个的找出到底应该负责处理
	链接上的请求，可以是一条链、一个树、一个环。模式本身不约束，这个需要自己去实现，但是在一个时刻命令只允许一个对象传给另一个对象，而不允许传给多个对象
	
十五、Facade--外观模式
	外观模式是为了解决类与类之间的依赖关系，像Spring一样，可以将；类与类之间的关系配置到配置文件中，而外观模式就是将他们的关系放到Facade类中，降低类与类之间的耦合度
	
十六、Mediator--中介者模式
	中介者模式也是用来降低类与类之间耦合的，如果类与类之间有依赖关系，不利于功能的扩展和维护，因为只要修改一个对象，其他关联的对象都得修改。若使用中介者模式，只需要关心中介类的关系，具体类之间的关系和调度叫个中介类就行了。
	
十七、Observer--观察者模式
	当一个对象变化时，其他依赖该对象都会接到通知，并且随着变化，对象之间是一种一对多的关系
	
十八、Memento--备忘录模式
	假设有原型A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，而C类就是一个用来存储备忘录的，且只能存储，不能修改等操作。
	
十九、State--状态模式
	当对象状态改变是，同事也改变行为
	
二十、Flyweight-享元模式
	主要目的是实现对象的共享，即共享池，当系统中对象多的时候，可以减少开销，通常与工厂模式一起使用。例如：数据库连接的4大属性值：URL、diverClassName、username、password
	
二十一、Proxy--代理模式
	如果已有的方法在使用的时候需要对原有方法进行改进，则
	1、修改原方法来适应，但这样违反“对扩展开放，对修改关闭”的原则
	2、采用代理类调用原有的方法，且对产生的结果控制
	
二十二、Command--命令模式
	命令模式的目的就是达到命令的发出者和执行者之间的解耦，实现请求和执行分开，熟悉Struts的话，其实就是将请求和呈现（响应）分离的技术
	
二十三、Interpreter--解释器模式
	解释器模式用来做各种各样的解释器。例如正则表达式解释器等
	
总体来说设计模式分三大类
	创建型模式（五种）：工厂方法、抽象工厂、单例、建造者、原型
	结构型模式（七种）：适配器、装饰器、代理、外观、桥接、责任链、组合、享元
	行为型模式（十一种）：策略、模板方法、观察者、迭代、责任链、命令、备忘录、状态、访问者、中介者、解释器
	
设计模式的六大原则
	开闭原则：对扩展开放，对修改关闭
	里氏代换原则：任何基类可以出现的地方，子类一定可以出现
	依赖倒转原则：针对接口编程，依赖于抽象，而不依赖于具体
	接口隔离原则：使用多个隔离的接口，比使用单个接口好
	迪米特法则：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相互独立
	合成复用原则：尽量使用合成/聚合的方式，而不是使用继承。